"""Notification sender for cascade alerts via multiple channels."""

import os
import httpx
from typing import Dict, Any
from datetime import datetime


class NotificationSender:
    """Handles sending alerts to various notification channels."""

    def __init__(self):
        self.smtp_server = os.getenv("SMTP_SERVER", "smtp.gmail.com")
        self.smtp_port = int(os.getenv("SMTP_PORT", "587"))
        self.smtp_username = os.getenv("SMTP_USERNAME")
        self.smtp_password = os.getenv("SMTP_PASSWORD")
        self.twilio_account_sid = os.getenv("TWILIO_ACCOUNT_SID")
        self.twilio_auth_token = os.getenv("TWILIO_AUTH_TOKEN")
        self.twilio_phone_number = os.getenv("TWILIO_PHONE_NUMBER")

    async def send_email(self, to_address: str, alert_data: Dict[str, Any]) -> bool:
        """
        Send email notification.

        Args:
            to_address: Email address to send to
            alert_data: Alert data containing event and cascade info

        Returns:
            True if sent successfully, False otherwise
        """
        try:
            import smtplib
            from email.mime.text import MIMEText
            from email.mime.multipart import MIMEMultipart

            if not self.smtp_username or not self.smtp_password:
                print("Email credentials not configured")
                return False

            event = alert_data['event']
            cascade = alert_data['cascade']

            # Create email
            msg = MIMEMultipart('alternative')
            msg['Subject'] = f"üö® {event['ticker']} Earnings Alert - {abs(event['surprise_percent']):.1f}% Surprise"
            msg['From'] = self.smtp_username
            msg['To'] = to_address

            # HTML body
            html = f"""
            <html>
                <body style="font-family: monospace; background: #000; color: #00ff00; padding: 20px;">
                    <h2 style="color: #00ffff;">‚ö†Ô∏è CASCADE ALERT</h2>
                    <div style="border: 2px solid #00ff00; padding: 15px; margin: 10px 0;">
                        <h3>{event['ticker']} - {event['company']}</h3>
                        <p><strong>Earnings Surprise:</strong>
                        <span style="color: {'#00ff00' if event['surprise_percent'] > 0 else '#ff0000'}">
                            {event['surprise_percent']:+.1f}%
                        </span></p>
                        <p><strong>Report Time:</strong> {event['report_time']}</p>
                    </div>
                    <div style="border: 2px solid #00ffff; padding: 15px; margin: 10px 0;">
                        <h3>CASCADE EFFECTS</h3>
                        <p><strong>Total Effects Detected:</strong> {cascade.get('total_effects', 0)}</p>
                        <p><strong>Prediction Horizon:</strong> {cascade.get('horizon_days', 14)} days</p>
                    </div>
                    <p style="margin-top: 20px;">
                        <a href="https://consequence.ai/predict?ticker={event['ticker']}&surprise={event['surprise_percent']}"
                           style="background: #00ff00; color: #000; padding: 10px 20px; text-decoration: none; font-weight: bold;">
                            VIEW FULL CASCADE ‚Üí
                        </a>
                    </p>
                    <p style="color: #666; font-size: 10px; margin-top: 30px;">
                        Generated by Consequence AI | {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}
                    </p>
                </body>
            </html>
            """

            msg.attach(MIMEText(html, 'html'))

            # Send email
            with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:
                server.starttls()
                server.login(self.smtp_username, self.smtp_password)
                server.send_message(msg)

            print(f"Email sent to {to_address}")
            return True

        except Exception as e:
            print(f"Failed to send email: {e}")
            return False

    async def send_slack(self, webhook_url: str, alert_data: Dict[str, Any]) -> bool:
        """
        Send Slack notification via webhook.

        Args:
            webhook_url: Slack webhook URL
            alert_data: Alert data containing event and cascade info

        Returns:
            True if sent successfully, False otherwise
        """
        try:
            event = alert_data['event']
            cascade = alert_data['cascade']

            surprise_emoji = "üìà" if event['surprise_percent'] > 0 else "üìâ"
            color = "#00ff00" if event['surprise_percent'] > 0 else "#ff0000"

            # Slack message format
            message = {
                "text": f"{surprise_emoji} *{event['ticker']} Earnings Alert*",
                "attachments": [
                    {
                        "color": color,
                        "fields": [
                            {
                                "title": "Company",
                                "value": event['company'],
                                "short": True
                            },
                            {
                                "title": "Surprise",
                                "value": f"{event['surprise_percent']:+.1f}%",
                                "short": True
                            },
                            {
                                "title": "Cascade Effects",
                                "value": f"{cascade.get('total_effects', 0)} effects detected",
                                "short": True
                            },
                            {
                                "title": "Horizon",
                                "value": f"{cascade.get('horizon_days', 14)} days",
                                "short": True
                            }
                        ],
                        "actions": [
                            {
                                "type": "button",
                                "text": "View Full Cascade",
                                "url": f"https://consequence.ai/predict?ticker={event['ticker']}&surprise={event['surprise_percent']}"
                            }
                        ],
                        "footer": "Consequence AI",
                        "ts": int(datetime.utcnow().timestamp())
                    }
                ]
            }

            async with httpx.AsyncClient() as client:
                response = await client.post(webhook_url, json=message)
                response.raise_for_status()

            print(f"Slack notification sent")
            return True

        except Exception as e:
            print(f"Failed to send Slack notification: {e}")
            return False

    async def send_whatsapp(self, phone_number: str, alert_data: Dict[str, Any]) -> bool:
        """
        Send WhatsApp notification via Twilio.

        Args:
            phone_number: Phone number to send to (E.164 format)
            alert_data: Alert data containing event and cascade info

        Returns:
            True if sent successfully, False otherwise
        """
        try:
            if not self.twilio_account_sid or not self.twilio_auth_token:
                print("Twilio credentials not configured")
                return False

            event = alert_data['event']
            cascade = alert_data['cascade']

            message_text = f"""
üö® *{event['ticker']} EARNINGS ALERT*

Company: {event['company']}
Surprise: {event['surprise_percent']:+.1f}%
Cascade: {cascade.get('total_effects', 0)} effects

View full cascade:
https://consequence.ai/predict?ticker={event['ticker']}

‚Äî Consequence AI
            """.strip()

            # Twilio API endpoint
            url = f"https://api.twilio.com/2010-04-01/Accounts/{self.twilio_account_sid}/Messages.json"

            data = {
                "From": f"whatsapp:{self.twilio_phone_number}",
                "To": f"whatsapp:{phone_number}",
                "Body": message_text
            }

            async with httpx.AsyncClient() as client:
                response = await client.post(
                    url,
                    data=data,
                    auth=(self.twilio_account_sid, self.twilio_auth_token)
                )
                response.raise_for_status()

            print(f"WhatsApp message sent to {phone_number}")
            return True

        except Exception as e:
            print(f"Failed to send WhatsApp message: {e}")
            return False

    async def send_sms(self, phone_number: str, alert_data: Dict[str, Any]) -> bool:
        """
        Send SMS notification via Twilio.

        Args:
            phone_number: Phone number to send to (E.164 format)
            alert_data: Alert data containing event and cascade info

        Returns:
            True if sent successfully, False otherwise
        """
        try:
            if not self.twilio_account_sid or not self.twilio_auth_token:
                print("Twilio credentials not configured")
                return False

            event = alert_data['event']
            cascade = alert_data['cascade']

            message_text = f"{event['ticker']} Alert: {event['surprise_percent']:+.1f}% surprise, {cascade.get('total_effects', 0)} cascade effects. View: https://consequence.ai/predict?ticker={event['ticker']}"

            # Twilio API endpoint
            url = f"https://api.twilio.com/2010-04-01/Accounts/{self.twilio_account_sid}/Messages.json"

            data = {
                "From": self.twilio_phone_number,
                "To": phone_number,
                "Body": message_text
            }

            async with httpx.AsyncClient() as client:
                response = await client.post(
                    url,
                    data=data,
                    auth=(self.twilio_account_sid, self.twilio_auth_token)
                )
                response.raise_for_status()

            print(f"SMS sent to {phone_number}")
            return True

        except Exception as e:
            print(f"Failed to send SMS: {e}")
            return False

    async def send_all(self, preferences: Dict[str, Any], alert_data: Dict[str, Any]) -> Dict[str, bool]:
        """
        Send notifications to all enabled channels.

        Args:
            preferences: User notification preferences
            alert_data: Alert data to send

        Returns:
            Dictionary mapping channel name to success status
        """
        results = {}

        if preferences.get('email_enabled') and preferences.get('email_address'):
            results['email'] = await self.send_email(preferences['email_address'], alert_data)

        if preferences.get('slack_enabled') and preferences.get('slack_webhook'):
            results['slack'] = await self.send_slack(preferences['slack_webhook'], alert_data)

        if preferences.get('whatsapp_enabled') and preferences.get('whatsapp_number'):
            results['whatsapp'] = await self.send_whatsapp(preferences['whatsapp_number'], alert_data)

        if preferences.get('sms_enabled') and preferences.get('sms_number'):
            results['sms'] = await self.send_sms(preferences['sms_number'], alert_data)

        return results


# Global notification sender instance
notification_sender = NotificationSender()
